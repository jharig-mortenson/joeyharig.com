import debounce from 'lodash.debounce';
import { useEffect, useState, useMemo } from 'react';
import hash from 'hash-object';
import axios from 'axios';
export { default as axios } from 'axios';

var CancelToken = axios.CancelToken;
/**
 * The object returned by the useAPI hook.
 * @typedef {Object} useAPIOutput
 * @property {Object|undefined} data - The data attribute from the axios response.
 * @property {Object|undefined} response - The axios response.
 * @property {Object|undefined} error - The axios error object if an error occurs.
 * @property {boolean} isLoading - Indicates if their is a pending API call.
 * @property {function} fetch - Function used to manually call a fetch method.
 * @property {setDataFunc} setData - Set the response data object.
 */

/**
 * `setData` property of `useAPIOutput`.
 *
 * Function used to overwrite the `data` object held instate.
 *
 * @typedef {function} setDataFunc
 * @param {Object[]} newData - New data array that overwrites current data.
 */

/**
 * React hook used to make a an API call using axios.
 *
 *  ```
 *  const { data, response, error, isLoading, setData, fetch } = useAPI(url, config, initialFetch);
 *  ```
 *
 * Allows you to pass an [axios config object](https://github.com/axios/axios#request-config), for complete control of the request being sent.
 *
 * @param {string} url - URL that the API call is made to.
 * @param {Object} config={} - Axios config object passed to the axios.request method.
 * @param {boolean} initialFetch=true - Should the first api call automatically be made.
 * @returns {useAPIOutput} output
 */

function useAPI(url, config, initialFetch) {
  if ( config === void 0 ) config = {};
  if ( initialFetch === void 0 ) initialFetch = true;

  var ref = useState({
    response: undefined,
    error: undefined,
    isLoading: true
  });
  var state = ref[0];
  var setState = ref[1];
  var configHash = hash(config);
  var source = CancelToken.source();

  function fetch() {
    axios(url, Object.assign({}, config,
      {cancelToken: source.token})).then(function (response) {
      setState({
        error: undefined,
        response: response,
        isLoading: false
      });
    }).catch(function (error) {
      if (axios.isCancel(error)) {
        console.log('Request canceled by cleanup: ', error.message);
      } else {
        setState({
          error: error,
          response: undefined,
          isLoading: false
        });
      }
    });
  }

  useEffect(function () {
    setState(Object.assign({}, state,
      {isLoading: true}));

    if (initialFetch) {
      fetch();
    }

    return function () {
      source.cancel('useEffect cleanup.');
    };
  }, [url, configHash]);
  var response = state.response;
  var error = state.error;
  var isLoading = state.isLoading;

  function setData(newData) {
    // Used to update state from component
    var newResponse = Object.assign({}, response,
      {data: newData});
    setState(Object.assign({}, state,
      {response: newResponse}));
  }

  var data = response ? response.data : undefined;
  return {
    data: data,
    response: response,
    error: error,
    isLoading: isLoading,
    setData: setData,
    fetch: fetch
  };
}

/**
 * The object returned by the useParams hook.
 * @typedef {Object} useParamsOutput
 * @property {Object} params - The current params to be used when making an API call.
 * @property {boolean} isStale - Is their a debounced params update waiting to timeout. (Are we waiting for the user to stop typing)
 * @property {setParamsFunc} setParams - Function used to set new parameters
 * @property {updateParamsFunc} updateParams - Function used to update current parameters
 * @property {setParamsFunc} debouncedSetParams - Debounced call made to `setParams`
 * @property {updateParamsFunc} debouncedUpdateParams - Debounced call made to `updateParams`
 */

/**
 * `setParams` property of `useParamsOutput`
 * @typedef {function} setParamsFunc
 * @param {Object} newParams - New params object that overwrites the current params.
 */

/**
 * `updateParams` property of `useParamsOutput`
 * @typedef {function} updateParamsFunc
 * @param {Object} paramsUpdate - Partial update to be merged with current params.
 */

/**
 * React hook to keep query parameters in state.
 *
 * Used in conjunction with the other hooks to filter and paginate APIs.
 *
 * Includes the ability the debounce an update, which is useful for delaying API calls while the user is typing.
 *
 * @param {Object} initialParams - The initial parameters to keep in states
 * @param {number} debounceWait=500 - The time to debounce the params update when calling debouncedUpdateParams
 * @returns {useParamsOutput} output
 */

function useParams(initialParams, debounceWait) {
  if ( initialParams === void 0 ) initialParams = {};
  if ( debounceWait === void 0 ) debounceWait = 500;

  var ref = useState(initialParams);
  var params = ref[0];
  var setParams = ref[1];
  var ref$1 = useState(false);
  var isStale = ref$1[0];
  var setIsStale = ref$1[1];

  function updateParams(updatedParams) {
    var newParams = Object.assign({}, params,
      updatedParams);
    setParams(newParams);
  }

  var debouncedSetParams = useMemo(function () { return debounce(function (newParams) {
    setIsStale(false);
    setParams(newParams);
  }, debounceWait); }, []);
  return {
    params: params,
    isStale: isStale,
    setParams: setParams,
    debouncedSetParams: function (newParams) {
      setIsStale(true);
      debouncedSetParams(newParams);
    },
    updateParams: updateParams,
    debouncedUpdateParams: function (updatedParams) {
      setIsStale(true);
      debouncedSetParams(Object.assign({}, params,
        updatedParams));
    }
  };
}

/**
 * Uses offset pagination strategy to page through results in an infite scroller.
 *
 * Change the 'offsetParamName' to customize the paginator to your API.
 *
 * E.g. you may need to use `offsetParamName='skip'`, `offsetParamName='start'`
 *
 * @param {Object} config - Axios config object
 * @param {Object} paginationState - Object kept internally to keep track of pagination
 * @param {string} offsetParamName - Param name used to send offset value to the API
 * @param {number} pageSize - Increment size for offset.
 * @return {Object[]} output
 * @return {Object} output.updatedConfig - Config object including pagination changes
 * @return {Object} output.updatedPaginationState - Updated pagination state
 */
function offsetPaginator(config, paginationState, offsetParamName, pageSize) {
  var obj;

  var params = config.params; if ( params === void 0 ) params = {};
  var offset = paginationState.offset;
  var newOffset = offset !== undefined ? offset + pageSize : 0;
  var updatedParams = Object.assign({}, params,
    ( obj = {}, obj[offsetParamName] = newOffset, obj ));
  var updatedConfig = Object.assign({}, config,
    {params: updatedParams});
  var updatedPaginationState = {
    offset: newOffset
  };
  return [updatedConfig, updatedPaginationState];
}
/**
 * Generate your own offset paginator with custom offset param names and page sizes.
 * @param offsetParamName
 * @param pageSize
 * @return {function} paginatorFunc
 */

function getOffsetPaginator(offsetParamName, pageSize) {
  return function (config, paginationState) { return offsetPaginator(config, paginationState, offsetParamName, pageSize); };
}
/**
 * Default `responseToItems` function. Assumes that the API response is an array of items.
 * @param response {Object} - Axios response object
 * @return output {Object}
 * @return output.items {Object[]} - Items extracted from the response
 * @return output.hasMore {boolean} - Are there more items available?
 */

function responseToData(response, pageSize) {
  var items = response.data;
  var hasMore = items.length === pageSize;
  return [items, hasMore];
}
/**
 * Generate a response to data function using a custom page size.
 *
 * If results.length === pageSize then it is assumed that there are more pages available.
 * @param pageSize
 * @return {function} responseToDataFunc
 */

function getResponseToData(pageSize) {
  return function (response) {
    return responseToData(response, pageSize);
  };
}

var CancelToken$1 = axios.CancelToken;
var defaultPaginator = getOffsetPaginator('offset', 40);
var defaultResponseToData = getResponseToData(40);
/**
 * Paginator function used to alter the axios config object, in order to fetch the next page.
 * @typedef {function} paginatorFunc
 * @param config {Object} - Axios config object
 * @param paginationState {Object} - Object kept internally to keep track of pagination
 * @return output {Object[]} - Return tuple \[updatedConfig: Object, updatedPaginationState: Object\]
 */

/**
 * Function used to extract items from the API response.
 * @typedef {function} responseToItemsFunc
 * @param response {Object} - Axios response object
 * @return output {Object} - Return tuple \[items: Object[], hasMore: boolean\]
 */

/**
 * The object returned by the useInfAPI hook.
 * @typedef {Object} useInfAPIOutput
 * @property {Object[]} items - Items provided by the API
 * @property {Object|undefined} error - The axios error object is an error occurs.
 * @property {boolean} isLoading - Indicates if their is a pending API call for the **first** page of items.
 * @property {boolean} isPaging - Indicates if their is a pending API call for the **any** page of items.
 * @property {setItemsFunc} setItems - Set the items being kept in state
 * @property {responseToItemsFunc} fetchPage - Function called from the component in order to fetch the next page
 */

/**
 * `setItems` property of `useInfAPIOutput`
 * @typedef {function} setItemsFunc
 * @param {Object[]} newItems - New items array that overwrites current data.
 */

/**
 * React hook used by an infinite scrolling component to make API calls using axios.
 *
 * ```
 *  const { items, error, isPaging, isLoading, hasMore, setItems, fetchPage } = useAPI(url, config, initialFetch);
 *  ```
 *
 * Allows you to pass an [axios config object](https://github.com/axios/axios#request-config), for complete control of the request being sent.
 *
 * By default it will paginate using a query param `offset`, and assumes that the API returns an array of items.
 *
 * If this is not appropriate for your API, then you will need to provide your own `paginator` and `responseToItems` functions.
 *
 * @param {string} url - URL that the API call is made to.
 * @param {Object} config={} - Axios config object passed to the axios.request method.
 * @param {paginatorFunc} paginator=offsetPaginator - Function used to update the config object in order to paginate
 * @param {function} responseToItems=responseToData - Function used to extract an array of items from response object.
 * @returns {useInfAPIOutput} output
 */

function useInfAPI(url, config, paginator, responseToItems) {
  if ( config === void 0 ) config = {};
  if ( paginator === void 0 ) paginator = defaultPaginator;
  if ( responseToItems === void 0 ) responseToItems = defaultResponseToData;

  var ref = useState({
    items: [],
    paginationState: {},
    error: undefined,
    isLoading: true,
    isPaging: true,
    hasMore: false
  });
  var state = ref[0];
  var setState = ref[1];
  var configHash = hash(config);
  var items = state.items;
  var paginationState = state.paginationState;
  var source = CancelToken$1.source();

  function callAPI(isLoading) {
    var activePaginationState = isLoading ? {} : paginationState; // Reset pagination when config object changes.

    var ref = paginator(config, activePaginationState);
    var updatedConfig = ref[0];
    var updatedPaginationState = ref[1];
    setState(Object.assign({}, state,
      {isLoading: isLoading,
      isPaging: true,
      paginationState: updatedPaginationState,
      items: isLoading ? [] : items}));
    axios(url, Object.assign({}, updatedConfig,
      {cancelToken: source.token})).then(function (response) {
      var ref = responseToItems(response);
      var pageItems = ref[0];
      var hasMore = ref[1];

      if (typeof pageItems === typeof []) {
        setState(Object.assign({}, state,
          {items: isLoading ? pageItems : items.concat(pageItems),
          // If the config object changed, the reset items
          error: undefined,
          isLoading: false,
          isPaging: false,
          hasMore: hasMore,
          paginationState: updatedPaginationState}));
      } else {
        console.log("Warning: responseToItems didn't return an array.");
      }
    }).catch(function (error) {
      if (axios.isCancel(error)) {
        console.log('Request canceled by cleanup: ', error.message);
      } else {
        setState(Object.assign({}, state,
          {error: error,
          isLoading: false,
          isPaging: false}));
      }
    });
  }

  useEffect(function () {
    callAPI(true);
    return function () {
      source.cancel('useEffect cleanup.');
    };
  }, [url, configHash]);
  var error = state.error;
  var isPaging = state.isPaging;
  var isLoading = state.isLoading;
  var hasMore = state.hasMore;
  return {
    items: items,
    error: error,
    isPaging: isPaging,
    isLoading: isLoading,
    hasMore: hasMore,
    setItems: function (newItems) { return setState(Object.assign({}, state,
      {items: newItems})); },
    fetchPage: function () { return callAPI(false); }
  };
}

// Allow access to lib axios instance in order to override defaults

export { useAPI, useParams, useInfAPI, getOffsetPaginator };
